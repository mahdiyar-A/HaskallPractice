Recursion, lists, tuples, and higher order functions.
Fall 2025
Objective
Haskell’s strong support for a rich variety of datatypes means that functions which would
be tedious and error-prone to write in other languages are often relatively simple in
Haskell. This assignment will be focused on using Haskell to model simple problems in
combinatorics, which nicely demonstrates Haskell’s power to concisely specify complex
computations.

IMPORTANT NOTE: Even if you know a closed-form formula that answers a question,
you should not use it in the functions you program for this assignment. These questions
are mostly concerned with counting the number of solutions to a given problem, and you
are expected to use recursion and list comprehension to actually generate a list containing
all solutions in order to count them.

Problem 1: iteratedCartesianProduct (20 points)
Write a function iteratedCartesianProduct :: [a] -> Int -> [[a]] which takes a
non-empty list l and an integer n ≥ 1 and returns a list containing every single possible
list of length n where each value is an element of l.
i.e. your iteratedCartesianProduct effectively returns the cartesian product of a list with
itself iterated n times: l × l × l × ... × l = ln
For example
iteratedCartesianProduct [1,2] 3 =
[[1,1,1], [1,1,2], [1,2,1], [1,2,2], [2,1,1], [2,1,2], [2,2,1], [2,2,2]]

Problem 2: numSums (20 points)
Using your iteratedCartesianProduct function, write a function
numSums :: Int -> Int which takes an integer n ≥ 1 as an argument and returns
the number of sums that add up to n.
For example
numSums 4 = 5
because 4 = 1 + 3 = 2 + 2 = 1 + 1 + 2 = 1 + 1 + 1 + 1 (note that we consider 4 to be a
one-term sum).
For the purposes of the question, two sums are considered identical exactly when
they have the same set of summands; we won’t consider ’rearrangements’ of a sum to be
different sums here, and we only consider sums with positive integers as summands. i.e.
1+1+2, 1+2+1, and 2+1+1 should all be considered as the same sum.

Problem 3: ballsIntoBins (20 points)
Using your iteratedCartesianProduct function, write a function
ballsIntoBins :: Int -> Int -> Int which takes two integers, k and n, as ar-
guments and returns the number of ways can we distribute k balls among n bins such
that each bin has at least one ball. We consider each bin to be distinct, while all balls are
identical.
For example
ballsIntoBins 4 3 = 3
while
ballsIntoBins 2 3 = 0

Problem 4: Round Table (40 points)
Suppose there are n people, each wearing a jersey with a unique number from 1 to n who
sit down together at a round table.
An ’i-run’ is a sequence of i people sitting next to each other, such that:
• The first person’s number is one less than the second person’s.
• the second person’s number is one less than the third’s
...
• the (i-1)-th person’s number is one less than the i-th’s
for example, in the following configuration:
there are two runs circled in red: one of length 3 and one of length 2. Notice that it
doesn’t matter whether the run goes clockwise or counterclockwise!
This question will guide you through writing a function
iRunLessArrs :: Int -> Int -> Int which takes two arguments, n and i (where
n, i ≥ 2) and returns the number of seating arrangements for n people with no i-runs.
The overall idea will be to represent a seating arrangement as a list of numbers
from 1 to n, with each place in the list representing a position at the table. For example,
the list [1,3,4,5,2] corresponds to the seating arrangement

Note that in this scheme, the person who is first in the list sits next to the person who is last.
In the first two parts of this question, you will write a function
twoRunLessArrs :: Int -> Int that takes the number of people n as an argu-
ment and returns the number of seating arrangements when i = 2.
(a) (10 marks)
Your first job is to write a function hasConsecElem :: [Int] -> Bool which takes
a list of integers representing a seating arrangement and returns whether or not
there are any runs of length 2.
For example
hasConsecElem [1,2,5,3,6,4] = True
hasConsecElem [6,4,2,1,5,3] = True
hasConsecElem [1,3,5,4,6,2] = True
(note the ’wraparound’ in the last list!)
while
hasConsecElem [1,3,5,2,6,4] = False
(b) (10 marks)
Now you’re ready to write twoRunLessArrs. Your implementation should work by
first making a list of all valid seating arrangements with no duplicates and then
filtering out the ones that have i-runs. Make sure to account for the fact that our
lists represent cycles – i.e. [1,2,3,4,5] represents the same seating arrangement as
[3,4,5,1,2]. We don’t want two lists in our list of all possible seating arrangements
that represent the same arrangement.
(c) (10 marks)



The next part of this question involves generalizing our function so that we can com-
pute the number of possible seating arrangements when i ≥ 2. Write a function
hasConsecSubl :: [Int] -> Int -> Bool which takes in a seating arrangement
and an integer i and returns True if the arrangement has an i-run and False oth-
erwise. Again, remember that the seating arrangements are cyclic! For example,
hasConsecSubl [4,6,7,5,1,2,3] 3 = True because the list has a 3-run starting
at 1.
Also remember that runs can go in either direction – [1,6,7,4,5,3,2] also has a 3-run
starting at 3!
(d) (10 marks)
Now write iRunLessArrs :: Int -> Int -> Int using the same strategy you used
for twoRunLessArrs.

